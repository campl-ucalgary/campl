{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for MplAsmLanguage.
--   Generated by the BNF converter.

module MplAsmLanguage.PrintMPLASM where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified MplAsmLanguage.AbsMPLASM

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print MplAsmLanguage.AbsMPLASM.Store where
  prt _ (MplAsmLanguage.AbsMPLASM.Store (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Load where
  prt _ (MplAsmLanguage.AbsMPLASM.Load (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Ret where
  prt _ (MplAsmLanguage.AbsMPLASM.Ret (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Call where
  prt _ (MplAsmLanguage.AbsMPLASM.Call (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.CInt where
  prt _ (MplAsmLanguage.AbsMPLASM.CInt (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.CChar where
  prt _ (MplAsmLanguage.AbsMPLASM.CChar (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.CBool where
  prt _ (MplAsmLanguage.AbsMPLASM.CBool (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.CString where
  prt _ (MplAsmLanguage.AbsMPLASM.CString (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.ToStr where
  prt _ (MplAsmLanguage.AbsMPLASM.ToStr (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.ToInt where
  prt _ (MplAsmLanguage.AbsMPLASM.ToInt (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.And where
  prt _ (MplAsmLanguage.AbsMPLASM.And (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Or where
  prt _ (MplAsmLanguage.AbsMPLASM.Or (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Append where
  prt _ (MplAsmLanguage.AbsMPLASM.Append (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Unstring where
  prt _ (MplAsmLanguage.AbsMPLASM.Unstring (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.LeqI where
  prt _ (MplAsmLanguage.AbsMPLASM.LeqI (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.EqI where
  prt _ (MplAsmLanguage.AbsMPLASM.EqI (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.EqB where
  prt _ (MplAsmLanguage.AbsMPLASM.EqB (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.LeqC where
  prt _ (MplAsmLanguage.AbsMPLASM.LeqC (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.EqC where
  prt _ (MplAsmLanguage.AbsMPLASM.EqC (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Leqs where
  prt _ (MplAsmLanguage.AbsMPLASM.Leqs (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Eqs where
  prt _ (MplAsmLanguage.AbsMPLASM.Eqs (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.ConcatS where
  prt _ (MplAsmLanguage.AbsMPLASM.ConcatS (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Add where
  prt _ (MplAsmLanguage.AbsMPLASM.Add (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Subtract where
  prt _ (MplAsmLanguage.AbsMPLASM.Subtract (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Mul where
  prt _ (MplAsmLanguage.AbsMPLASM.Mul (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Quot where
  prt _ (MplAsmLanguage.AbsMPLASM.Quot (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Rem where
  prt _ (MplAsmLanguage.AbsMPLASM.Rem (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Case where
  prt _ (MplAsmLanguage.AbsMPLASM.Case (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.If where
  prt _ (MplAsmLanguage.AbsMPLASM.If (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Rec where
  prt _ (MplAsmLanguage.AbsMPLASM.Rec (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Get where
  prt _ (MplAsmLanguage.AbsMPLASM.Get (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Put where
  prt _ (MplAsmLanguage.AbsMPLASM.Put (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Hput where
  prt _ (MplAsmLanguage.AbsMPLASM.Hput (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Shput where
  prt _ (MplAsmLanguage.AbsMPLASM.Shput (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Hcase where
  prt _ (MplAsmLanguage.AbsMPLASM.Hcase (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Split where
  prt _ (MplAsmLanguage.AbsMPLASM.Split (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Fork where
  prt _ (MplAsmLanguage.AbsMPLASM.Fork (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Plug where
  prt _ (MplAsmLanguage.AbsMPLASM.Plug (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Run where
  prt _ (MplAsmLanguage.AbsMPLASM.Run (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Race where
  prt _ (MplAsmLanguage.AbsMPLASM.Race (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Close where
  prt _ (MplAsmLanguage.AbsMPLASM.Close (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Halt where
  prt _ (MplAsmLanguage.AbsMPLASM.Halt (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Ch_Id where
  prt _ (MplAsmLanguage.AbsMPLASM.Ch_Id (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Main_run where
  prt _ (MplAsmLanguage.AbsMPLASM.Main_run (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.BBool where
  prt _ (MplAsmLanguage.AbsMPLASM.BBool (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.Character where
  prt _ (MplAsmLanguage.AbsMPLASM.Character (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.UIdent where
  prt _ (MplAsmLanguage.AbsMPLASM.UIdent (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.PIdent where
  prt _ (MplAsmLanguage.AbsMPLASM.PIdent (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.PInteger where
  prt _ (MplAsmLanguage.AbsMPLASM.PInteger (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.IIdent where
  prt _ (MplAsmLanguage.AbsMPLASM.IIdent (_,i)) = doc $ showString i
instance Print MplAsmLanguage.AbsMPLASM.AMPLCODE where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.AMPLCODE amplconstructss main -> prPrec i 0 (concatD [prt 0 amplconstructss, prt 0 main])

instance Print MplAsmLanguage.AbsMPLASM.AmplConstructs where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.IMPORT_CONSTRUCT import_ -> prPrec i 0 (concatD [prt 0 import_])
    MplAsmLanguage.AbsMPLASM.PROTOCOL_CONSTRUCT protocols -> prPrec i 0 (concatD [prt 0 protocols])
    MplAsmLanguage.AbsMPLASM.COPROTOCOL_CONSTRUCT coprotocols -> prPrec i 0 (concatD [prt 0 coprotocols])
    MplAsmLanguage.AbsMPLASM.CONSTRUCTOR_CONSTRUCT constructors -> prPrec i 0 (concatD [prt 0 constructors])
    MplAsmLanguage.AbsMPLASM.DESTRUCTOR_CONSTRUCT destructors -> prPrec i 0 (concatD [prt 0 destructors])
    MplAsmLanguage.AbsMPLASM.PROCESSES_CONSTRUCT processes -> prPrec i 0 (concatD [prt 0 processes])
    MplAsmLanguage.AbsMPLASM.FUNCTIONS_CONSTRUCT functions -> prPrec i 0 (concatD [prt 0 functions])

instance Print [MplAsmLanguage.AbsMPLASM.AmplConstructs] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.ProtocolCoprotocolSpec where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.PROTOCOL_COPROTOCOL_SPEC uident handles -> prPrec i 0 (concatD [prt 0 uident, doc (showString "="), doc (showString "{"), prt 0 handles, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.Handle where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.HANDLE_NAME uident -> prPrec i 0 (concatD [prt 0 uident])

instance Print [MplAsmLanguage.AbsMPLASM.ProtocolCoprotocolSpec] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [MplAsmLanguage.AbsMPLASM.Handle] where
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.Import where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.IMPORT iident -> prPrec i 0 (concatD [doc (showString "%include"), prt 0 iident])

instance Print MplAsmLanguage.AbsMPLASM.Constructors where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.CONSTRUCTORS structorspecs -> prPrec i 0 (concatD [doc (showString "%constructors"), doc (showString ":"), doc (showString "{"), prt 0 structorspecs, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.Destructors where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.DESTRUCTORS structorspecs -> prPrec i 0 (concatD [doc (showString "%destructors"), doc (showString ":"), doc (showString "{"), prt 0 structorspecs, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.StructorSpec where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.STRUCT_SPEC uident structs -> prPrec i 0 (concatD [prt 0 uident, doc (showString "="), doc (showString "{"), prt 0 structs, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.Struct where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.STRUCT uident pinteger -> prPrec i 0 (concatD [prt 0 uident, prt 0 pinteger])

instance Print [MplAsmLanguage.AbsMPLASM.StructorSpec] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [MplAsmLanguage.AbsMPLASM.Struct] where
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.Protocols where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.PROTOCOLS protocolcoprotocolspecs -> prPrec i 0 (concatD [doc (showString "%protocols"), doc (showString ":"), doc (showString "{"), prt 0 protocolcoprotocolspecs, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.Coprotocols where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.COPROTOCOLS protocolcoprotocolspecs -> prPrec i 0 (concatD [doc (showString "%coprotocols"), doc (showString ":"), doc (showString "{"), prt 0 protocolcoprotocolspecs, doc (showString "}")])

instance Print MplAsmLanguage.AbsMPLASM.Processes where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.PROCESSES processesspecs -> prPrec i 0 (concatD [doc (showString "%processes"), doc (showString ":"), doc (showString "{"), prt 0 processesspecs, doc (showString "}")])

instance Print [MplAsmLanguage.AbsMPLASM.ProcessesSpec] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.ProcessesSpec where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.PROCESS_SPEC pident pidents1 pidents2 pidents3 coms -> prPrec i 0 (concatD [prt 0 pident, doc (showString "("), prt 0 pidents1, doc (showString "|"), prt 0 pidents2, doc (showString "=>"), prt 0 pidents3, doc (showString ")"), doc (showString "="), prt 0 coms])

instance Print [MplAsmLanguage.AbsMPLASM.PIdent] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.Functions where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.FUNCTIONS functionsspecs -> prPrec i 0 (concatD [doc (showString "%functions"), doc (showString ":"), doc (showString "{"), prt 0 functionsspecs, doc (showString "}")])

instance Print [MplAsmLanguage.AbsMPLASM.FunctionsSpec] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.FunctionsSpec where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.FUNCTION_SPEC pident pidents coms -> prPrec i 0 (concatD [prt 0 pident, doc (showString "("), prt 0 pidents, doc (showString ")"), doc (showString "="), prt 0 coms])

instance Print MplAsmLanguage.AbsMPLASM.Main where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.MAIN mainrun mainchannels coms -> prPrec i 0 (concatD [prt 0 mainrun, prt 0 mainchannels, doc (showString ":"), prt 0 coms])
    MplAsmLanguage.AbsMPLASM.NO_MAIN -> prPrec i 0 (concatD [])

instance Print MplAsmLanguage.AbsMPLASM.MainChannels where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.MAIN_CHANNELS pidents1 pidents2 -> prPrec i 0 (concatD [doc (showString "("), doc (showString "|"), prt 0 pidents1, doc (showString "=>"), prt 0 pidents2, doc (showString ")")])

instance Print MplAsmLanguage.AbsMPLASM.Coms where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.Prog coms -> prPrec i 0 (concatD [doc (showString "{"), prt 0 coms, doc (showString "}")])

instance Print [MplAsmLanguage.AbsMPLASM.Com] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.Com where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.AC_ASSIGN pident com -> prPrec i 0 (concatD [prt 0 pident, doc (showString ":="), prt 0 com])
    MplAsmLanguage.AbsMPLASM.AC_STORE store pident -> prPrec i 0 (concatD [prt 0 store, prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_LOAD load pident -> prPrec i 0 (concatD [prt 0 load, prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_RET ret -> prPrec i 0 (concatD [prt 0 ret])
    MplAsmLanguage.AbsMPLASM.AC_CALL_FUN call pident pidents -> prPrec i 0 (concatD [prt 0 call, prt 0 pident, doc (showString "("), prt 0 pidents, doc (showString ")")])
    MplAsmLanguage.AbsMPLASM.AC_INT cint pinteger -> prPrec i 0 (concatD [prt 0 cint, prt 0 pinteger])
    MplAsmLanguage.AbsMPLASM.AC_CHAR cchar character -> prPrec i 0 (concatD [prt 0 cchar, prt 0 character])
    MplAsmLanguage.AbsMPLASM.AC_STRING cstring str -> prPrec i 0 (concatD [prt 0 cstring, printString str])
    MplAsmLanguage.AbsMPLASM.AC_TOSTR tostr -> prPrec i 0 (concatD [prt 0 tostr])
    MplAsmLanguage.AbsMPLASM.AC_TOINT toint -> prPrec i 0 (concatD [prt 0 toint])
    MplAsmLanguage.AbsMPLASM.AC_AND and -> prPrec i 0 (concatD [prt 0 and])
    MplAsmLanguage.AbsMPLASM.AC_OR or -> prPrec i 0 (concatD [prt 0 or])
    MplAsmLanguage.AbsMPLASM.AC_APPEND append -> prPrec i 0 (concatD [prt 0 append])
    MplAsmLanguage.AbsMPLASM.AC_BOOL cbool bbool -> prPrec i 0 (concatD [prt 0 cbool, prt 0 bbool])
    MplAsmLanguage.AbsMPLASM.AC_UNSTRING unstring -> prPrec i 0 (concatD [prt 0 unstring])
    MplAsmLanguage.AbsMPLASM.AC_EQB eqb -> prPrec i 0 (concatD [prt 0 eqb])
    MplAsmLanguage.AbsMPLASM.AC_LEQ leqi -> prPrec i 0 (concatD [prt 0 leqi])
    MplAsmLanguage.AbsMPLASM.AC_EQI eqi -> prPrec i 0 (concatD [prt 0 eqi])
    MplAsmLanguage.AbsMPLASM.AC_LEQC leqc -> prPrec i 0 (concatD [prt 0 leqc])
    MplAsmLanguage.AbsMPLASM.AC_EQC eqc -> prPrec i 0 (concatD [prt 0 eqc])
    MplAsmLanguage.AbsMPLASM.AC_LEQS leqs -> prPrec i 0 (concatD [prt 0 leqs])
    MplAsmLanguage.AbsMPLASM.AC_EQS eqs -> prPrec i 0 (concatD [prt 0 eqs])
    MplAsmLanguage.AbsMPLASM.AC_CONCAT concats n -> prPrec i 0 (concatD [prt 0 concats, prt 0 n])
    MplAsmLanguage.AbsMPLASM.AC_ADD add -> prPrec i 0 (concatD [prt 0 add])
    MplAsmLanguage.AbsMPLASM.AC_SUB subtract -> prPrec i 0 (concatD [prt 0 subtract])
    MplAsmLanguage.AbsMPLASM.AC_MUL mul -> prPrec i 0 (concatD [prt 0 mul])
    MplAsmLanguage.AbsMPLASM.AC_DIVQ quot -> prPrec i 0 (concatD [prt 0 quot])
    MplAsmLanguage.AbsMPLASM.AC_DIVR rem -> prPrec i 0 (concatD [prt 0 rem])
    MplAsmLanguage.AbsMPLASM.AC_CONSTRUCTOR uident1 uident2 -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2])
    MplAsmLanguage.AbsMPLASM.AC_CONSTRUCTOR_ARGS uident1 uident2 pidents -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2, doc (showString "("), prt 0 pidents, doc (showString ")")])
    MplAsmLanguage.AbsMPLASM.AC_CASE case_ pident labelledcomss -> prPrec i 0 (concatD [prt 0 case_, prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 labelledcomss, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_IF if_ pident coms1 coms2 -> prPrec i 0 (concatD [prt 0 if_, prt 0 pident, doc (showString "then"), prt 0 coms1, doc (showString "else"), prt 0 coms2])
    MplAsmLanguage.AbsMPLASM.AC_RECORD rec_ labelledcomss -> prPrec i 0 (concatD [prt 0 rec_, doc (showString "of"), doc (showString "{"), prt 0 labelledcomss, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_DEST uident1 uident2 pident -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2, prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_DEST_ARGS uident1 uident2 pidents pident -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2, doc (showString "("), prt 0 pidents, doc (showString ")"), prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_PROD pidents -> prPrec i 0 (concatD [doc (showString "("), prt 0 pidents, doc (showString ")")])
    MplAsmLanguage.AbsMPLASM.AC_PRODELEM pinteger pident -> prPrec i 0 (concatD [doc (showString "#"), prt 0 pinteger, doc (showString "("), prt 0 pident, doc (showString ")")])
    MplAsmLanguage.AbsMPLASM.AC_EMSG str -> prPrec i 0 (concatD [printString str])
    MplAsmLanguage.AbsMPLASM.AC_GET get pident1 pident2 -> prPrec i 0 (concatD [prt 0 get, prt 0 pident1, doc (showString "on"), prt 0 pident2])
    MplAsmLanguage.AbsMPLASM.AC_PUT put pident1 pident2 -> prPrec i 0 (concatD [prt 0 put, prt 0 pident1, doc (showString "on"), prt 0 pident2])
    MplAsmLanguage.AbsMPLASM.AC_HPUT hput uident1 uident2 pident -> prPrec i 0 (concatD [prt 0 hput, prt 0 uident1, doc (showString "."), prt 0 uident2, doc (showString "on"), prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_SHPUT shput uident pident -> prPrec i 0 (concatD [prt 0 shput, prt 0 uident, doc (showString "on"), prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_HCASE hcase pident labelledcomss -> prPrec i 0 (concatD [prt 0 hcase, prt 0 pident, doc (showString "of"), doc (showString "{"), prt 0 labelledcomss, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_SPLIT split pident1 pident2 pident3 -> prPrec i 0 (concatD [prt 0 split, prt 0 pident1, doc (showString "into"), prt 0 pident2, prt 0 pident3])
    MplAsmLanguage.AbsMPLASM.AC_FORK fork pident1 pident2 pidents1 coms1 pident3 pidents2 coms2 -> prPrec i 0 (concatD [prt 0 fork, prt 0 pident1, doc (showString "as"), doc (showString "{"), prt 0 pident2, doc (showString "with"), prt 0 pidents1, doc (showString ":"), prt 0 coms1, doc (showString ";"), prt 0 pident3, doc (showString "with"), prt 0 pidents2, doc (showString ":"), prt 0 coms2, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_PLUG plug pidents1 pidents2 pidents3 coms1 pidents4 pidents5 coms2 -> prPrec i 0 (concatD [prt 0 plug, prt 0 pidents1, doc (showString "as"), doc (showString "{"), doc (showString "with"), doc (showString "["), prt 0 pidents2, doc (showString "|"), prt 0 pidents3, doc (showString "]"), doc (showString ":"), prt 0 coms1, doc (showString ";"), doc (showString "with"), doc (showString "["), prt 0 pidents4, doc (showString "|"), prt 0 pidents5, doc (showString "]"), doc (showString ":"), prt 0 coms2, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_RUN run pident pidents1 pidents2 pidents3 -> prPrec i 0 (concatD [prt 0 run, prt 0 pident, doc (showString "("), prt 0 pidents1, doc (showString "|"), prt 0 pidents2, doc (showString "=>"), prt 0 pidents3, doc (showString ")")])
    MplAsmLanguage.AbsMPLASM.AC_ID pident1 chid pident2 -> prPrec i 0 (concatD [prt 0 pident1, prt 0 chid, prt 0 pident2])
    MplAsmLanguage.AbsMPLASM.AC_RACE race racephrases -> prPrec i 0 (concatD [prt 0 race, doc (showString "{"), prt 0 racephrases, doc (showString "}")])
    MplAsmLanguage.AbsMPLASM.AC_CLOSE close pident -> prPrec i 0 (concatD [prt 0 close, prt 0 pident])
    MplAsmLanguage.AbsMPLASM.AC_HALT halt pident -> prPrec i 0 (concatD [prt 0 halt, prt 0 pident])

instance Print MplAsmLanguage.AbsMPLASM.LabelledComs where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.AC_LABELLED_COMS_NO_ARGS uident1 uident2 coms -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2, doc (showString ":"), prt 0 coms])
    MplAsmLanguage.AbsMPLASM.AC_LABELLED_COMS uident1 uident2 pidents coms -> prPrec i 0 (concatD [prt 0 uident1, doc (showString "."), prt 0 uident2, doc (showString "("), prt 0 pidents, doc (showString ")"), doc (showString ":"), prt 0 coms])

instance Print [MplAsmLanguage.AbsMPLASM.Coms] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [MplAsmLanguage.AbsMPLASM.LabelledComs] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print MplAsmLanguage.AbsMPLASM.RACE_PHRASE where
  prt i = \case
    MplAsmLanguage.AbsMPLASM.AC_RACE_PHRASE pident coms -> prPrec i 0 (concatD [prt 0 pident, doc (showString "->"), prt 0 coms])

instance Print [MplAsmLanguage.AbsMPLASM.RACE_PHRASE] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]
