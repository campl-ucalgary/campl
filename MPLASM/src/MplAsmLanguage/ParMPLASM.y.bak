-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module MplAsmLanguage.ParMPLASM
  ( happyError
  , myLexer
  , pAMPLCODE
  ) where

import Prelude

import qualified MplAsmLanguage.AbsMPLASM
import MplAsmLanguage.LexMPLASM

}

%name pAMPLCODE AMPLCODE
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#'             { PT _ (TS _ 1)        }
  '%constructors' { PT _ (TS _ 2)        }
  '%coprotocols'  { PT _ (TS _ 3)        }
  '%destructors'  { PT _ (TS _ 4)        }
  '%functions'    { PT _ (TS _ 5)        }
  '%include'      { PT _ (TS _ 6)        }
  '%processes'    { PT _ (TS _ 7)        }
  '%protocols'    { PT _ (TS _ 8)        }
  '('             { PT _ (TS _ 9)        }
  ')'             { PT _ (TS _ 10)       }
  ','             { PT _ (TS _ 11)       }
  '->'            { PT _ (TS _ 12)       }
  '.'             { PT _ (TS _ 13)       }
  ':'             { PT _ (TS _ 14)       }
  ':='            { PT _ (TS _ 15)       }
  ';'             { PT _ (TS _ 16)       }
  '='             { PT _ (TS _ 17)       }
  '=>'            { PT _ (TS _ 18)       }
  '['             { PT _ (TS _ 19)       }
  ']'             { PT _ (TS _ 20)       }
  'as'            { PT _ (TS _ 21)       }
  'else'          { PT _ (TS _ 22)       }
  'into'          { PT _ (TS _ 23)       }
  'of'            { PT _ (TS _ 24)       }
  'on'            { PT _ (TS _ 25)       }
  'then'          { PT _ (TS _ 26)       }
  'with'          { PT _ (TS _ 27)       }
  '{'             { PT _ (TS _ 28)       }
  '|'             { PT _ (TS _ 29)       }
  '}'             { PT _ (TS _ 30)       }
  L_integ         { PT _ (TI $$)         }
  L_quoted        { PT _ (TL $$)         }
  L_Store         { PT _ (T_Store _)     }
  L_Load          { PT _ (T_Load _)      }
  L_Ret           { PT _ (T_Ret _)       }
  L_Call          { PT _ (T_Call _)      }
  L_CInt          { PT _ (T_CInt _)      }
  L_CChar         { PT _ (T_CChar _)     }
  L_CBool         { PT _ (T_CBool _)     }
  L_CString       { PT _ (T_CString _)   }
  L_ToStr         { PT _ (T_ToStr _)     }
  L_ToInt         { PT _ (T_ToInt _)     }
  L_And           { PT _ (T_And _)       }
  L_Or            { PT _ (T_Or _)        }
  L_Append        { PT _ (T_Append _)    }
  L_Unstring      { PT _ (T_Unstring _)  }
  L_LeqI          { PT _ (T_LeqI _)      }
  L_EqI           { PT _ (T_EqI _)       }
  L_EqB           { PT _ (T_EqB _)       }
  L_LeqC          { PT _ (T_LeqC _)      }
  L_EqC           { PT _ (T_EqC _)       }
  L_Leqs          { PT _ (T_Leqs _)      }
  L_Eqs           { PT _ (T_Eqs _)       }
  L_ConcatS       { PT _ (T_ConcatS _)   }
  L_Add           { PT _ (T_Add _)       }
  L_Subtract      { PT _ (T_Subtract _)  }
  L_Mul           { PT _ (T_Mul _)       }
  L_Quot          { PT _ (T_Quot _)      }
  L_Rem           { PT _ (T_Rem _)       }
  L_Case          { PT _ (T_Case _)      }
  L_If            { PT _ (T_If _)        }
  L_Rec           { PT _ (T_Rec _)       }
  L_Get           { PT _ (T_Get _)       }
  L_Put           { PT _ (T_Put _)       }
  L_Hput          { PT _ (T_Hput _)      }
  L_Shput         { PT _ (T_Shput _)     }
  L_Hcase         { PT _ (T_Hcase _)     }
  L_Split         { PT _ (T_Split _)     }
  L_Fork          { PT _ (T_Fork _)      }
  L_Plug          { PT _ (T_Plug _)      }
  L_Run           { PT _ (T_Run _)       }
  L_Race          { PT _ (T_Race _)      }
  L_Close         { PT _ (T_Close _)     }
  L_Halt          { PT _ (T_Halt _)      }
  L_Ch_Id         { PT _ (T_Ch_Id _)     }
  L_Main_run      { PT _ (T_Main_run _)  }
  L_BBool         { PT _ (T_BBool _)     }
  L_Character     { PT _ (T_Character _) }
  L_UIdent        { PT _ (T_UIdent _)    }
  L_PIdent        { PT _ (T_PIdent _)    }
  L_PInteger      { PT _ (T_PInteger _)  }
  L_IIdent        { PT _ (T_IIdent _)    }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Store :: { MplAsmLanguage.AbsMPLASM.Store }
Store  : L_Store { MplAsmLanguage.AbsMPLASM.Store (mkPosToken $1) }

Load :: { MplAsmLanguage.AbsMPLASM.Load }
Load  : L_Load { MplAsmLanguage.AbsMPLASM.Load (mkPosToken $1) }

Ret :: { MplAsmLanguage.AbsMPLASM.Ret }
Ret  : L_Ret { MplAsmLanguage.AbsMPLASM.Ret (mkPosToken $1) }

Call :: { MplAsmLanguage.AbsMPLASM.Call }
Call  : L_Call { MplAsmLanguage.AbsMPLASM.Call (mkPosToken $1) }

CInt :: { MplAsmLanguage.AbsMPLASM.CInt }
CInt  : L_CInt { MplAsmLanguage.AbsMPLASM.CInt (mkPosToken $1) }

CChar :: { MplAsmLanguage.AbsMPLASM.CChar }
CChar  : L_CChar { MplAsmLanguage.AbsMPLASM.CChar (mkPosToken $1) }

CBool :: { MplAsmLanguage.AbsMPLASM.CBool }
CBool  : L_CBool { MplAsmLanguage.AbsMPLASM.CBool (mkPosToken $1) }

CString :: { MplAsmLanguage.AbsMPLASM.CString }
CString  : L_CString { MplAsmLanguage.AbsMPLASM.CString (mkPosToken $1) }

ToStr :: { MplAsmLanguage.AbsMPLASM.ToStr }
ToStr  : L_ToStr { MplAsmLanguage.AbsMPLASM.ToStr (mkPosToken $1) }

ToInt :: { MplAsmLanguage.AbsMPLASM.ToInt }
ToInt  : L_ToInt { MplAsmLanguage.AbsMPLASM.ToInt (mkPosToken $1) }

And :: { MplAsmLanguage.AbsMPLASM.And }
And  : L_And { MplAsmLanguage.AbsMPLASM.And (mkPosToken $1) }

Or :: { MplAsmLanguage.AbsMPLASM.Or }
Or  : L_Or { MplAsmLanguage.AbsMPLASM.Or (mkPosToken $1) }

Append :: { MplAsmLanguage.AbsMPLASM.Append }
Append  : L_Append { MplAsmLanguage.AbsMPLASM.Append (mkPosToken $1) }

Unstring :: { MplAsmLanguage.AbsMPLASM.Unstring }
Unstring  : L_Unstring { MplAsmLanguage.AbsMPLASM.Unstring (mkPosToken $1) }

LeqI :: { MplAsmLanguage.AbsMPLASM.LeqI }
LeqI  : L_LeqI { MplAsmLanguage.AbsMPLASM.LeqI (mkPosToken $1) }

EqI :: { MplAsmLanguage.AbsMPLASM.EqI }
EqI  : L_EqI { MplAsmLanguage.AbsMPLASM.EqI (mkPosToken $1) }

EqB :: { MplAsmLanguage.AbsMPLASM.EqB }
EqB  : L_EqB { MplAsmLanguage.AbsMPLASM.EqB (mkPosToken $1) }

LeqC :: { MplAsmLanguage.AbsMPLASM.LeqC }
LeqC  : L_LeqC { MplAsmLanguage.AbsMPLASM.LeqC (mkPosToken $1) }

EqC :: { MplAsmLanguage.AbsMPLASM.EqC }
EqC  : L_EqC { MplAsmLanguage.AbsMPLASM.EqC (mkPosToken $1) }

Leqs :: { MplAsmLanguage.AbsMPLASM.Leqs }
Leqs  : L_Leqs { MplAsmLanguage.AbsMPLASM.Leqs (mkPosToken $1) }

Eqs :: { MplAsmLanguage.AbsMPLASM.Eqs }
Eqs  : L_Eqs { MplAsmLanguage.AbsMPLASM.Eqs (mkPosToken $1) }

ConcatS :: { MplAsmLanguage.AbsMPLASM.ConcatS }
ConcatS  : L_ConcatS { MplAsmLanguage.AbsMPLASM.ConcatS (mkPosToken $1) }

Add :: { MplAsmLanguage.AbsMPLASM.Add }
Add  : L_Add { MplAsmLanguage.AbsMPLASM.Add (mkPosToken $1) }

Subtract :: { MplAsmLanguage.AbsMPLASM.Subtract }
Subtract  : L_Subtract { MplAsmLanguage.AbsMPLASM.Subtract (mkPosToken $1) }

Mul :: { MplAsmLanguage.AbsMPLASM.Mul }
Mul  : L_Mul { MplAsmLanguage.AbsMPLASM.Mul (mkPosToken $1) }

Quot :: { MplAsmLanguage.AbsMPLASM.Quot }
Quot  : L_Quot { MplAsmLanguage.AbsMPLASM.Quot (mkPosToken $1) }

Rem :: { MplAsmLanguage.AbsMPLASM.Rem }
Rem  : L_Rem { MplAsmLanguage.AbsMPLASM.Rem (mkPosToken $1) }

Case :: { MplAsmLanguage.AbsMPLASM.Case }
Case  : L_Case { MplAsmLanguage.AbsMPLASM.Case (mkPosToken $1) }

If :: { MplAsmLanguage.AbsMPLASM.If }
If  : L_If { MplAsmLanguage.AbsMPLASM.If (mkPosToken $1) }

Rec :: { MplAsmLanguage.AbsMPLASM.Rec }
Rec  : L_Rec { MplAsmLanguage.AbsMPLASM.Rec (mkPosToken $1) }

Get :: { MplAsmLanguage.AbsMPLASM.Get }
Get  : L_Get { MplAsmLanguage.AbsMPLASM.Get (mkPosToken $1) }

Put :: { MplAsmLanguage.AbsMPLASM.Put }
Put  : L_Put { MplAsmLanguage.AbsMPLASM.Put (mkPosToken $1) }

Hput :: { MplAsmLanguage.AbsMPLASM.Hput }
Hput  : L_Hput { MplAsmLanguage.AbsMPLASM.Hput (mkPosToken $1) }

Shput :: { MplAsmLanguage.AbsMPLASM.Shput }
Shput  : L_Shput { MplAsmLanguage.AbsMPLASM.Shput (mkPosToken $1) }

Hcase :: { MplAsmLanguage.AbsMPLASM.Hcase }
Hcase  : L_Hcase { MplAsmLanguage.AbsMPLASM.Hcase (mkPosToken $1) }

Split :: { MplAsmLanguage.AbsMPLASM.Split }
Split  : L_Split { MplAsmLanguage.AbsMPLASM.Split (mkPosToken $1) }

Fork :: { MplAsmLanguage.AbsMPLASM.Fork }
Fork  : L_Fork { MplAsmLanguage.AbsMPLASM.Fork (mkPosToken $1) }

Plug :: { MplAsmLanguage.AbsMPLASM.Plug }
Plug  : L_Plug { MplAsmLanguage.AbsMPLASM.Plug (mkPosToken $1) }

Run :: { MplAsmLanguage.AbsMPLASM.Run }
Run  : L_Run { MplAsmLanguage.AbsMPLASM.Run (mkPosToken $1) }

Race :: { MplAsmLanguage.AbsMPLASM.Race }
Race  : L_Race { MplAsmLanguage.AbsMPLASM.Race (mkPosToken $1) }

Close :: { MplAsmLanguage.AbsMPLASM.Close }
Close  : L_Close { MplAsmLanguage.AbsMPLASM.Close (mkPosToken $1) }

Halt :: { MplAsmLanguage.AbsMPLASM.Halt }
Halt  : L_Halt { MplAsmLanguage.AbsMPLASM.Halt (mkPosToken $1) }

Ch_Id :: { MplAsmLanguage.AbsMPLASM.Ch_Id }
Ch_Id  : L_Ch_Id { MplAsmLanguage.AbsMPLASM.Ch_Id (mkPosToken $1) }

Main_run :: { MplAsmLanguage.AbsMPLASM.Main_run }
Main_run  : L_Main_run { MplAsmLanguage.AbsMPLASM.Main_run (mkPosToken $1) }

BBool :: { MplAsmLanguage.AbsMPLASM.BBool }
BBool  : L_BBool { MplAsmLanguage.AbsMPLASM.BBool (mkPosToken $1) }

Character :: { MplAsmLanguage.AbsMPLASM.Character }
Character  : L_Character { MplAsmLanguage.AbsMPLASM.Character (mkPosToken $1) }

UIdent :: { MplAsmLanguage.AbsMPLASM.UIdent }
UIdent  : L_UIdent { MplAsmLanguage.AbsMPLASM.UIdent (mkPosToken $1) }

PIdent :: { MplAsmLanguage.AbsMPLASM.PIdent }
PIdent  : L_PIdent { MplAsmLanguage.AbsMPLASM.PIdent (mkPosToken $1) }

PInteger :: { MplAsmLanguage.AbsMPLASM.PInteger }
PInteger  : L_PInteger { MplAsmLanguage.AbsMPLASM.PInteger (mkPosToken $1) }

IIdent :: { MplAsmLanguage.AbsMPLASM.IIdent }
IIdent  : L_IIdent { MplAsmLanguage.AbsMPLASM.IIdent (mkPosToken $1) }

AMPLCODE :: { MplAsmLanguage.AbsMPLASM.AMPLCODE }
AMPLCODE
  : ListAmplConstructs Main { MplAsmLanguage.AbsMPLASM.AMPLCODE $1 $2 }

AmplConstructs :: { MplAsmLanguage.AbsMPLASM.AmplConstructs }
AmplConstructs
  : Import { MplAsmLanguage.AbsMPLASM.IMPORT_CONSTRUCT $1 }
  | Protocols { MplAsmLanguage.AbsMPLASM.PROTOCOL_CONSTRUCT $1 }
  | Coprotocols { MplAsmLanguage.AbsMPLASM.COPROTOCOL_CONSTRUCT $1 }
  | Constructors { MplAsmLanguage.AbsMPLASM.CONSTRUCTOR_CONSTRUCT $1 }
  | Destructors { MplAsmLanguage.AbsMPLASM.DESTRUCTOR_CONSTRUCT $1 }
  | Processes { MplAsmLanguage.AbsMPLASM.PROCESSES_CONSTRUCT $1 }
  | Functions { MplAsmLanguage.AbsMPLASM.FUNCTIONS_CONSTRUCT $1 }

ListAmplConstructs :: { [MplAsmLanguage.AbsMPLASM.AmplConstructs] }
ListAmplConstructs
  : {- empty -} { [] }
  | AmplConstructs ListAmplConstructs { (:) $1 $2 }

ProtocolCoprotocolSpec :: { MplAsmLanguage.AbsMPLASM.ProtocolCoprotocolSpec }
ProtocolCoprotocolSpec
  : UIdent '=' '{' ListHandle '}' { MplAsmLanguage.AbsMPLASM.PROTOCOL_COPROTOCOL_SPEC $1 $4 }

Handle :: { MplAsmLanguage.AbsMPLASM.Handle }
Handle : UIdent { MplAsmLanguage.AbsMPLASM.HANDLE_NAME $1 }

ListProtocolCoprotocolSpec :: { [MplAsmLanguage.AbsMPLASM.ProtocolCoprotocolSpec] }
ListProtocolCoprotocolSpec
  : {- empty -} { [] }
  | ProtocolCoprotocolSpec { (:[]) $1 }
  | ProtocolCoprotocolSpec ';' ListProtocolCoprotocolSpec { (:) $1 $3 }

ListHandle :: { [MplAsmLanguage.AbsMPLASM.Handle] }
ListHandle
  : Handle { (:[]) $1 } | Handle ';' ListHandle { (:) $1 $3 }

Import :: { MplAsmLanguage.AbsMPLASM.Import }
Import : '%include' IIdent { MplAsmLanguage.AbsMPLASM.IMPORT $2 }

Constructors :: { MplAsmLanguage.AbsMPLASM.Constructors }
Constructors
  : '%constructors' ':' '{' ListStructorSpec '}' { MplAsmLanguage.AbsMPLASM.CONSTRUCTORS $4 }

Destructors :: { MplAsmLanguage.AbsMPLASM.Destructors }
Destructors
  : '%destructors' ':' '{' ListStructorSpec '}' { MplAsmLanguage.AbsMPLASM.DESTRUCTORS $4 }

StructorSpec :: { MplAsmLanguage.AbsMPLASM.StructorSpec }
StructorSpec
  : UIdent '=' '{' ListStruct '}' { MplAsmLanguage.AbsMPLASM.STRUCT_SPEC $1 $4 }

Struct :: { MplAsmLanguage.AbsMPLASM.Struct }
Struct : UIdent PInteger { MplAsmLanguage.AbsMPLASM.STRUCT $1 $2 }

ListStructorSpec :: { [MplAsmLanguage.AbsMPLASM.StructorSpec] }
ListStructorSpec
  : {- empty -} { [] }
  | StructorSpec { (:[]) $1 }
  | StructorSpec ';' ListStructorSpec { (:) $1 $3 }

ListStruct :: { [MplAsmLanguage.AbsMPLASM.Struct] }
ListStruct
  : Struct { (:[]) $1 } | Struct ';' ListStruct { (:) $1 $3 }

Protocols :: { MplAsmLanguage.AbsMPLASM.Protocols }
Protocols
  : '%protocols' ':' '{' ListProtocolCoprotocolSpec '}' { MplAsmLanguage.AbsMPLASM.PROTOCOLS $4 }

Coprotocols :: { MplAsmLanguage.AbsMPLASM.Coprotocols }
Coprotocols
  : '%coprotocols' ':' '{' ListProtocolCoprotocolSpec '}' { MplAsmLanguage.AbsMPLASM.COPROTOCOLS $4 }

Processes :: { MplAsmLanguage.AbsMPLASM.Processes }
Processes
  : '%processes' ':' '{' ListProcessesSpec '}' { MplAsmLanguage.AbsMPLASM.PROCESSES $4 }

ListProcessesSpec :: { [MplAsmLanguage.AbsMPLASM.ProcessesSpec] }
ListProcessesSpec
  : {- empty -} { [] }
  | ProcessesSpec { (:[]) $1 }
  | ProcessesSpec ';' ListProcessesSpec { (:) $1 $3 }

ProcessesSpec :: { MplAsmLanguage.AbsMPLASM.ProcessesSpec }
ProcessesSpec
  : PIdent '(' ListPIdent '|' ListPIdent '=>' ListPIdent ')' '=' Coms { MplAsmLanguage.AbsMPLASM.PROCESS_SPEC $1 $3 $5 $7 $10 }

ListPIdent :: { [MplAsmLanguage.AbsMPLASM.PIdent] }
ListPIdent
  : {- empty -} { [] }
  | PIdent { (:[]) $1 }
  | PIdent ',' ListPIdent { (:) $1 $3 }

Functions :: { MplAsmLanguage.AbsMPLASM.Functions }
Functions
  : '%functions' ':' '{' ListFunctionsSpec '}' { MplAsmLanguage.AbsMPLASM.FUNCTIONS $4 }

ListFunctionsSpec :: { [MplAsmLanguage.AbsMPLASM.FunctionsSpec] }
ListFunctionsSpec
  : {- empty -} { [] }
  | FunctionsSpec { (:[]) $1 }
  | FunctionsSpec ';' ListFunctionsSpec { (:) $1 $3 }

FunctionsSpec :: { MplAsmLanguage.AbsMPLASM.FunctionsSpec }
FunctionsSpec
  : PIdent '(' ListPIdent ')' '=' Coms { MplAsmLanguage.AbsMPLASM.FUNCTION_SPEC $1 $3 $6 }

Main :: { MplAsmLanguage.AbsMPLASM.Main }
Main
  : Main_run MainChannels ':' Coms { MplAsmLanguage.AbsMPLASM.MAIN $1 $2 $4 }
  | {- empty -} { MplAsmLanguage.AbsMPLASM.NO_MAIN }

MainChannels :: { MplAsmLanguage.AbsMPLASM.MainChannels }
MainChannels
  : '(' '|' ListPIdent '=>' ListPIdent ')' { MplAsmLanguage.AbsMPLASM.MAIN_CHANNELS $3 $5 }

Coms :: { MplAsmLanguage.AbsMPLASM.Coms }
Coms : '{' ListCom '}' { MplAsmLanguage.AbsMPLASM.Prog $2 }

ListCom :: { [MplAsmLanguage.AbsMPLASM.Com] }
ListCom
  : {- empty -} { [] }
  | Com { (:[]) $1 }
  | Com ';' ListCom { (:) $1 $3 }

Com :: { MplAsmLanguage.AbsMPLASM.Com }
Com
  : PIdent ':=' Com { MplAsmLanguage.AbsMPLASM.AC_ASSIGN $1 $3 }
  | Store PIdent { MplAsmLanguage.AbsMPLASM.AC_STORE $1 $2 }
  | Load PIdent { MplAsmLanguage.AbsMPLASM.AC_LOAD $1 $2 }
  | Ret { MplAsmLanguage.AbsMPLASM.AC_RET $1 }
  | Call PIdent '(' ListPIdent ')' { MplAsmLanguage.AbsMPLASM.AC_CALL_FUN $1 $2 $4 }
  | CInt PInteger { MplAsmLanguage.AbsMPLASM.AC_INT $1 $2 }
  | CChar Character { MplAsmLanguage.AbsMPLASM.AC_CHAR $1 $2 }
  | CString String { MplAsmLanguage.AbsMPLASM.AC_STRING $1 $2 }
  | ToStr { MplAsmLanguage.AbsMPLASM.AC_TOSTR $1 }
  | ToInt { MplAsmLanguage.AbsMPLASM.AC_TOINT $1 }
  | And { MplAsmLanguage.AbsMPLASM.AC_AND $1 }
  | Or { MplAsmLanguage.AbsMPLASM.AC_OR $1 }
  | Append { MplAsmLanguage.AbsMPLASM.AC_APPEND $1 }
  | CBool BBool { MplAsmLanguage.AbsMPLASM.AC_BOOL $1 $2 }
  | Unstring { MplAsmLanguage.AbsMPLASM.AC_UNSTRING $1 }
  | EqB { MplAsmLanguage.AbsMPLASM.AC_EQB $1 }
  | LeqI { MplAsmLanguage.AbsMPLASM.AC_LEQ $1 }
  | EqI { MplAsmLanguage.AbsMPLASM.AC_EQI $1 }
  | LeqC { MplAsmLanguage.AbsMPLASM.AC_LEQC $1 }
  | EqC { MplAsmLanguage.AbsMPLASM.AC_EQC $1 }
  | Leqs { MplAsmLanguage.AbsMPLASM.AC_LEQS $1 }
  | Eqs { MplAsmLanguage.AbsMPLASM.AC_EQS $1 }
  | ConcatS Integer { MplAsmLanguage.AbsMPLASM.AC_CONCAT $1 $2 }
  | Add { MplAsmLanguage.AbsMPLASM.AC_ADD $1 }
  | Subtract { MplAsmLanguage.AbsMPLASM.AC_SUB $1 }
  | Mul { MplAsmLanguage.AbsMPLASM.AC_MUL $1 }
  | Quot { MplAsmLanguage.AbsMPLASM.AC_DIVQ $1 }
  | Rem { MplAsmLanguage.AbsMPLASM.AC_DIVR $1 }
  | UIdent '.' UIdent { MplAsmLanguage.AbsMPLASM.AC_CONSTRUCTOR $1 $3 }
  | UIdent '.' UIdent '(' ListPIdent ')' { MplAsmLanguage.AbsMPLASM.AC_CONSTRUCTOR_ARGS $1 $3 $5 }
  | Case PIdent 'of' '{' ListLabelledComs '}' { MplAsmLanguage.AbsMPLASM.AC_CASE $1 $2 $5 }
  | If PIdent 'then' Coms 'else' Coms { MplAsmLanguage.AbsMPLASM.AC_IF $1 $2 $4 $6 }
  | Rec 'of' '{' ListLabelledComs '}' { MplAsmLanguage.AbsMPLASM.AC_RECORD $1 $4 }
  | UIdent '.' UIdent PIdent { MplAsmLanguage.AbsMPLASM.AC_DEST $1 $3 $4 }
  | UIdent '.' UIdent '(' ListPIdent ')' PIdent { MplAsmLanguage.AbsMPLASM.AC_DEST_ARGS $1 $3 $5 $7 }
  | '(' ListPIdent ')' { MplAsmLanguage.AbsMPLASM.AC_PROD $2 }
  | '#' PInteger '(' PIdent ')' { MplAsmLanguage.AbsMPLASM.AC_PRODELEM $2 $4 }
  | String { MplAsmLanguage.AbsMPLASM.AC_EMSG $1 }
  | Get PIdent 'on' PIdent { MplAsmLanguage.AbsMPLASM.AC_GET $1 $2 $4 }
  | Put PIdent 'on' PIdent { MplAsmLanguage.AbsMPLASM.AC_PUT $1 $2 $4 }
  | Hput UIdent '.' UIdent 'on' PIdent { MplAsmLanguage.AbsMPLASM.AC_HPUT $1 $2 $4 $6 }
  | Shput UIdent 'on' PIdent { MplAsmLanguage.AbsMPLASM.AC_SHPUT $1 $2 $4 }
  | Hcase PIdent 'of' '{' ListLabelledComs '}' { MplAsmLanguage.AbsMPLASM.AC_HCASE $1 $2 $5 }
  | Split PIdent 'into' PIdent PIdent { MplAsmLanguage.AbsMPLASM.AC_SPLIT $1 $2 $4 $5 }
  | Fork PIdent 'as' '{' PIdent 'with' ListPIdent ':' Coms ';' PIdent 'with' ListPIdent ':' Coms '}' { MplAsmLanguage.AbsMPLASM.AC_FORK $1 $2 $5 $7 $9 $11 $13 $15 }
  | Plug ListPIdent 'as' '{' 'with' '[' ListPIdent '|' ListPIdent ']' ':' Coms ';' 'with' '[' ListPIdent '|' ListPIdent ']' ':' Coms '}' { MplAsmLanguage.AbsMPLASM.AC_PLUG $1 $2 $7 $9 $12 $16 $18 $21 }
  | Run PIdent '(' ListPIdent '|' ListPIdent '=>' ListPIdent ')' { MplAsmLanguage.AbsMPLASM.AC_RUN $1 $2 $4 $6 $8 }
  | PIdent Ch_Id PIdent { MplAsmLanguage.AbsMPLASM.AC_ID $1 $2 $3 }
  | Race '{' ListRACE_PHRASE '}' { MplAsmLanguage.AbsMPLASM.AC_RACE $1 $3 }
  | Close PIdent { MplAsmLanguage.AbsMPLASM.AC_CLOSE $1 $2 }
  | Halt PIdent { MplAsmLanguage.AbsMPLASM.AC_HALT $1 $2 }

LabelledComs :: { MplAsmLanguage.AbsMPLASM.LabelledComs }
LabelledComs
  : UIdent '.' UIdent ':' Coms { MplAsmLanguage.AbsMPLASM.AC_LABELLED_COMS_NO_ARGS $1 $3 $5 }
  | UIdent '.' UIdent '(' ListPIdent ')' ':' Coms { MplAsmLanguage.AbsMPLASM.AC_LABELLED_COMS $1 $3 $5 $8 }

ListComs :: { [MplAsmLanguage.AbsMPLASM.Coms] }
ListComs
  : {- empty -} { [] }
  | Coms { (:[]) $1 }
  | Coms ',' ListComs { (:) $1 $3 }

ListLabelledComs :: { [MplAsmLanguage.AbsMPLASM.LabelledComs] }
ListLabelledComs
  : {- empty -} { [] }
  | LabelledComs { (:[]) $1 }
  | LabelledComs ';' ListLabelledComs { (:) $1 $3 }

RACE_PHRASE :: { MplAsmLanguage.AbsMPLASM.RACE_PHRASE }
RACE_PHRASE
  : PIdent '->' Coms { MplAsmLanguage.AbsMPLASM.AC_RACE_PHRASE $1 $3 }

ListRACE_PHRASE :: { [MplAsmLanguage.AbsMPLASM.RACE_PHRASE] }
ListRACE_PHRASE
  : {- empty -} { [] }
  | RACE_PHRASE { (:[]) $1 }
  | RACE_PHRASE ';' ListRACE_PHRASE { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

